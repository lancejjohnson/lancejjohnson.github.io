---
title: Setting up a Rails app
date: 2016-08-04 17:17 EDT
tags: rails
---

# Setting Up a Rails Application

## Install Ruby

Before you begin, you'll need to install Ruby on your system. Make sure you have version 2.2.1 or higher. <!-- TODO: insert link on installing Ruby. -->

## Install Rails

The first step in building a Rails application is installing the Rails gem on your machine. Once Ruby is installed you can accomplish this with a simple command on the command-line.

```shell
gem install rails --version "5.0.0"
```

The `--version` flag isn't necessary. Without it Ruby will install the most current version. I specified it here because I have other versions of Rails already installed and want to ensure I'm getting version 5 for this application.

## Generate the application "scaffold"

Now that you have installed Rails, you can generate the application "scaffold". Rails makes it very easy to create all the files you need for your basic and functioning Rails application.

```shell
rails new <name-of-your-app-goes-here>
```

Rails allows you to be pass specific configurations to the `rails new` command that taylors the generated application. I've decided to use PostgreSQL for my database and RSpec for my test framework. Rails doesn't include an option for setting up RSpec but I can tell it not to setup the default test framework by passing the `-T` flag. I can taylor the generated application for those options with the following command.

```shell
rails new cardrr -d postgresql -T
```

Rails will generate all the necessary files for the application and install the gems specified in the Gemfile.

## Install and configure RSpec

In order to test the application you need to install a test framework. I prefer RSpec to minitest for a number of reasons. Setting it up for Rails is fairly straightforward.

Add `rspec-rails` to the Gemfile under `group :development, :test do`.

```ruby
group :development, :test do
  gem 'rspec-rails'
end
```

Install the gem by running `bundle install`.

After bundle has finished, RSpec provides an initializer to help with setup.

```shell
$ bin/rails generate rspec:install
```

This produces `.rspec`, `spec/spec_helper.rb`, and `spec/rails_helper.rb` files.

<!-- TODO: Explain the function of these files. -->

### Configuring RSpec

The `spec/spec_helper.rb` file generated by RSpec is the place to configure RSpec. It includes several comments to help explain different bits of configuration and includes several common configurations that you can uncomment to make available.

Rather than walking through all the options, here's what your file should look like after removing the comments and including some of the provided options.

```ruby
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups
  config.filter_run_when_matching :focus
  config.disable_monkey_patching!
  config.default_formatter = 'doc' if config.files_to_run.one?
  config.order = :random
  Kernel.srand config.seed
end
```

## Setting up FactoryGirl

FactoryGirl is a gem that makes setting up data for testing easy, robust, and fast.

Add the gem to your Gemfile.

```ruby
# Gemfile
group :development, :test do
  # ...
  gem 'factory_girl_rails', '~> 4.7'
end
```

To configure FactoryGirl, create a file `spec/support/factory_girl.rb` and add the following:

```ruby
RSpec.configure do |config|
  config.include FactoryGirl::Syntax::Methods
end
```

This configuration allows you to use things like `build(:user)` in your specs rather than `FactoryGirl.build(:user)`. I prefer the more terse version but there are things to be said for the more robust version as well, so you can turn this off if you'd prefer.

In order for RSpec to use this code, however, you need to load it when RSpec loads. To do that, open `spec/rails_helper.rb` and uncomment the following line:

```ruby
Dir[Rails.root.join('spec/support/**/*.rb')].each { |f| require f }
```

This requires every file in `spec/support` including its subdirectories.

## Installing Shoulda-Matchers

Shoulda Matchers is a collection of custom matchers for RSpec that make testing Rails application simpler, cleaner, and more terse.

Add the gem to your Gemfile

```ruby
group :development, :test do
  # ...
  gem 'shoulda-matchers', '~> 3.1', '>= 3.1.1'
end
```

Configure shoulda matchers by adding this file:

```ruby
# spec/support/shoulda_matchers.rb
Shoulda::Matchers.configure do |config|
  config.integrate do |with|
    with.test_framework :rspec
    with.library :rails
  end
end
```

## Setting up DatabaseCleaner

DatabaseCleaner is a gem that will help ensure your test database is in an accurate state for test runs.

<!-- TODO: Research DatabaseCleaner and provide a better explanation. -->

Add the gem to your Gemfile.

To configure DatabaseCleaner, create a file `spec/support/database_cleaner.rb` and add the following:

```ruby
require 'database_cleaner'

RSpec.configure do |config|
  config.before(:suite) do
    DatabaseCleaner.clean_with(:deletion)
  end

  config.before(:each) do
    DatabaseCleaner.strategy = :transaction
  end

  config.before(:each, js: true) do
    DatabaseCleaner.strategy = :deletion
  end

  config.before(:each) do
    DatabaseCleaner.start
  end

  config.after(:each) do
    DatabaseCleaner.clean
  end
end
```

## Create the database

Now you need to create the database before you can run Rails.

```shell
bin/rails db:create
```

## Start up the app

You are now ready to fire up Rails. (Of course, we could have done this before all the testing configuration.)

```shell
bin/rails server
```

## Next Step

The next thing you'll want to do is deploy the application. This sounds like a strange next step. But following the advice of *Growing Object-Oriented Software Guided By Tests* if we get the application deployed, we know we have a functioning application and we can deploy the app after each iteration of devolopment, constantly delivering new features.
